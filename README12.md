**Аналитическая часть работы**
***Вариант 12. Поиск с имитацией отжига для раскраски графа ***
Задача: реализовать имитацию отжига для задачи раскраски графа с минимизацией числа 
цветов. 
Требования: 
- Входные данные: неориентированный граф 
- Выход: раскраска вершин и количество использованных цветов 
- Вывести текущее число конфликтов при понижении температуры 
Входные данные: 
Граф с 10 вершинами и 15 ребрами
#Анализ алгоритма: 
Алгоритм имитации отжига для раскраски графа начинает с инициализации, где все вершины окрашиваются в один цвет. Вычисление конфликтов через код for u, v in self.edges: if coloring[u] == coloring[v]: conflicts += 1 задает целевую функцию для минимизации. Одновременно оценивается минимальное количество цветов.
На каждой итерации генерируется соседнее решение комбинированным подходом. Строки if random.random() < 0.7: new_color = random.randint(1, num_colors) обеспечивают случайные изменения, а цикл for color in range(1, new_num_colors + 1): if color not in neighbor_colors: new_coloring[vertex] = color реализует жадную эвристику для локального улучшения.
Ключевой особенностью является вероятностный критерий в строках if delta < 0 or random.random() < math.exp(-delta / temperature). Этот механизм позволяет принимать ухудшающие решения, преодолевая локальные оптимумы. При высоких температурах доминирует исследование, с охлаждением - эксплуатация.
Стратегия уменьшения цветов активируется условием if current_conflicts == 0 and current_num_colors > min_colors: new_num_colors = current_num_colors - 1. После проверки возможности сокращения палитры алгоритм перераспределяет цвета, используя эвристику минимального доступного цвета.
Температурный режим управляется строкой temperature *= cooling_rate, реализующей геометрическое охлаждение. Экспоненциальное снижение температуры обеспечивает плавный переход между фазами поиска. Сохранение лучшего решения через if current_conflicts < best_conflicts: best_coloring = current_coloring.copy() гарантирует качество финального результата.
Алгоритм завершается при достижении минимальной температуры или лимита итераций. Финальная раскраска сочетает минимальное количество цветов с наименьшим числом конфликтов, достигая эффективного решения задачи за счет комбинирования случайного поиска, жадных эвристик и вероятностного принятия решений.
#Временная сложность алгоритма: O(k * L * N), где:
k — количество итераций ("эпох") при изменении температуры.
L — длина цепочки Маркова (количество шагов при одной температуре).
N — количество вершин в графе.
#Почему: алгоритм не гарантирует нахождение точного решения за фиксированное время. Вместо этого он последовательно генерирует и проверяет соседние решения — перекрашивает случайные вершины и оценивает количество конфликтов. Поскольку на каждой итерации нужно проверить всех соседей измененной вершины (что в худшем случае составляет O(V) операций), а общее число итераций L задается параметрами алгоритма (начальной температурой и скоростью охлаждения), итоговая сложность становится O(L·V). Фактически, вы сами определяете сложность алгоритма, выбирая, как долго он будет работать — чем больше итераций L, тем лучше результат, но дольше выполнение.


#Ответ на контрольный вопрос:
Критерий Метрополиса 
Какова формула критерия Метрополиса в алгоритме имитации отжига и что она означает?

Формула критерия Метрополиса — это правило, определяющее, принять ли ухудшающее решение в алгоритме имитации отжига, и записывается как P = e^(-ΔE / T), где ΔE — ухудшение качества решения, а T — «температура». Она означает, что если новое решение лучше текущего (ΔE ≤ 0), оно принимается всегда, а если хуже (ΔE > 0) — лишь с некоторой вероятностью. Ключевой смысл в том, что на старте алгоритма при высокой T вероятность принятия плохих решений велика, что позволяет системе «перепрыгивать» через локальные минимумы для глобального поиска, а по мере снижения T («остывания») алгоритм всё реже допускает ухудшения, стабилизируясь на около-оптимальном решении.
