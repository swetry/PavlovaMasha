Алгоритмы сортировки 
Блочная (корзинная) сортировка 
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет 
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их 
значений. После этого каждая корзина сортируется отдельно (либо тем же методом 
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины 
объединяются обратно в один массив.2 
Принцип работы: 
1.Определяется количество корзин (например, по диапазону значений элементов). buckets = [[] for _ in range(num_buckets)]  
2. Каждый элемент помещается в корзину согласно функции распределения. buckets[index].append(value) 
3. Содержимое каждой корзины сортируется индивидуально. sorted_bucket = insertion_sort(bucket)
4. Корзины соединяются в порядке увеличения диапазона. sorted_arr.extend(sorted_bucket)
Особенности: 
Эффективна для равномерно распределённых числовых данных и может достигать линейной 
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает 
при неравномерном распределении данных. 
Почему: Такая временная сложность обусловлена тремя основными факторами: распределение элементов по корзинам O(n), индивидуальная сортировка каждой корзины O(n^2/k (k - количество корзин)) и последующее объединение отсортированных корзин O(N). 

Блинная сортировка 
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции 
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые 
обменивают соседние элементы или выбирают опорные точки, здесь единственная 
разрешённая операция — переворот префикса массива до выбранного индекса. 
Принцип работы: 
1. Найти максимальный элемент в неотсортированной части массива. max_idx = find_max_idx(arr, curr_size)
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым. flip(arr, max_idx)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце. flip(arr, curr_size - 1)
4. Повторить процесс для оставшейся неотсортированной части массива. while curr_size > 1:    ...    curr_size -= 1
Особенности: 
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример 
нестандартных методов сортировки. 
Почему: на каждой итерации выполняются два основных шага: поиск максимального элемента (O(N) операций) и две операции переворота частей массива (каждая также требует порядка (O(N)).

Сортировка бусинами (гравитационная) 
Определение: Сортировка бусинами (bead sort), также известная как гравитационная 
сортировка, моделирует естественное поведение бусин, падающих вниз под действием 
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл 
Диннин в 2002 году. 
Принцип работы: 
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению. for i in range(len(arr)): …
2. Бусины располагаются на «стержнях» (как на абаке). созданием матрицы beads
3. Под действием «гравитации» бусины падают вниз. for j in range(max_val): …
4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив. result = [sum(row) for row in beads]
Особенности: 
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность — 
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
Почему: поскольку процесс сортировки включает два ключевых этапа: построение структуры ("абака") и последующий спуск бусинок. Время построения структуры пропорционально количеству элементов n, а время, необходимое для прохождения каждой бусинки снизу вверх и обратно вниз, зависит от среднего количества сравнений.

Алгоритмы поиска 
Поиск скачками (Jump Search) 
Определение: 
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при 
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы 
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного 
диапазона. 
Принцип работы: 
1. Делится массив на блоки длины m=n. step = int(math.sqrt(n))
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому. while arr[min(step, n)-1] < x:
3. Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке. Цикл: for i in range(prev, min(step, n)): ...
Особенности: 
В среднем сложность поиска O(n). 
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное 
время. 
Почему: изначально выполняются скачки длиной около по упорядоченному массиву, а затем применяется простой линейный поиск внутри небольшого блока размером также порядка . Таким образом, количество операций пропорционально сумме двух величин: числа больших скачков  и числа сравнений внутри финального блока . Оба значения имеют порядок роста O(n).

Экспоненциальный поиск (Exponential Search) 
Определение: 
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя 
быстро определить диапазон, в котором может находиться искомое значение, а затем 
применяет двоичный поиск в этом диапазоне. 
Принцип работы: 
1. Проверяется первый элемент массива. if arr[0] == x: ...
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому. while i < n and arr[i] <= x: ... 
3. На найденном диапазоне выполняется бинарный поиск. ... return binary_search(arr, i//2, last_idx-1, x)
Особенности: 
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с 
неизвестным размером или частичным доступом. 
Почему: поскольку сначала используется бинарный поиск по степеням двойки, чтобы определить подходящий диапазон поиска. Это занимает время порядка O(logn). Затем, после нахождения нужного диапазона, осуществляется классический бинарный поиск внутри интервала, который также требует O(logn) операций. 
