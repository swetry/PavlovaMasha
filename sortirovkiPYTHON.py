#сортировка вставками

def insertion_sort(arr):
    # Проходим по массиву начиная со второго элемента (i=1)
    for i in range(1, len(arr)):
        key = arr[i]           # Сохраняем значение текущего элемента
        
        j = i - 1              # Перемещаемся назад от текущего индекса
        
        # Если предыдущий элемент больше текущего,
        # сдвигаем элементы вправо, освобождая место для вставки нового значения
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1             # Продолжаем двигаться назад
            
        # Когда находим правильное место для вставки ключа, помещаем его туда
        arr[j + 1] = key

# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(arr)
print("Отсортированный массив:", arr)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#быстрая сортировка
def quick_sort(arr):
    # Базовый случай: если длина массива равна нулю или единице,
    # то массив уже отсортирован и мы возвращаем его обратно
    if len(arr) <= 1:
        return arr
    
    # Выбираем первый элемент массива в качестве опорного ("pivot")
    pivot = arr[len(arr) // 2]
    
    # Разделяем массив на три списка:
    # left - элементы, меньшие опорного
    # middle - элементы равные опорному
    # right - элементы большие опорного
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    # Рекурсивно применяем быструю сортировку к левым и правым частям
    # и объединяем результаты вместе с элементами, равными опорному
    return quick_sort(left) + middle + quick_sort(right)

# Пример использования:
if __name__ == "__main__":
    unsorted_array = [3, 6, 8, 10, 1, 2, 1]
    sorted_array = quick_sort(unsorted_array)
    print(f'Отсортированный массив: {sorted_array}')
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#последовательный посик
def sequential_search(arr, target):
    """
    Реализация последовательного поиска в массиве.
    :param arr: Список элементов, в котором осуществляется поиск.
    :param target: Элемент, который нужно найти.
    :return: Индекса элемента, если найден; иначе None.
    """
    # Пробегаемся по каждому элементу массива
    for index, element in enumerate(arr):
        # Если текущий элемент совпадает с искомым, возвращаем его индекс
        if element == target:
            return index
    # Если элемент не найден, возвращаем None
    return None

# Пример использования
if __name__ == "__main__":
    # Исходный массив
    my_list = [10, 20, 30, 40, 50]
    
    # Искомое значение
    search_value = 30
    
    # Производим поиск
    result = sequential_search(my_list, search_value)
    
    # Проверяем результат
    if result is not None:
        print(f"Значение найдено на позиции {result}.")
    else:
        print("Значение не найдено.")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Классический алгоритм поиска Фибоначчи
def fibonacci_search(arr, x):
    # Функция получает длину массива и цель поиска
    size = len(arr)
    
    # Начинаем строить последовательность Фибоначчи
    fib_2 = 0  # F(m-2)
    fib_1 = 1  # F(m-1)
    fib_m = fib_2 + fib_1  # Текущее число Фибоначчи F(m)
    
    # Продолжаем увеличивать числа Фибоначчи, пока они не станут больше размера массива
    while fib_m < size:
        fib_2 = fib_1
        fib_1 = fib_m
        fib_m = fib_2 + fib_1
    
    # Переменная для отслеживания нижней границы поиска
    offset = -1
    
    # Основное тело поиска: двигаемся по массиву, сравнивая элементы
    while fib_m > 1:
        # Вычисляем индекс элемента для проверки
        # Здесь важно учесть ограничение границ массива
        i = min(offset+fib_2, size-1)
        
        # Если текущее значение меньше цели, смещаем границу вперед
        if arr[i] < x:
            fib_m = fib_1  # Уменьшаем число Фибоначчи
            fib_1 = fib_2  # Обновляем предыдущее число
            fib_2 = fib_m - fib_1  # Предыдущее становится новым числом Фибоначчи
            offset = i  # Меняем нижнюю границу поиска
        
        # Если текущее значение больше цели, меняем направление поиска
        elif arr[i] > x:
            fib_m = fib_2  # Переходим к предыдущему числу Фибоначчи
            fib_1 = fib_1 - fib_2  # Предыдущее число уменьшается
            fib_2 = fib_m - fib_1  # Новое число Фибоначчи образуется из разницы
        
        # Если нашли совпадение, возвращаем индекс
        else:
            return i
    
    # Последняя проверка перед выходом
    if fib_1 and arr[offset+1]==x:
        return offset+1
    
    # Если ничего не найдено, возвращаем None
    return None


# Тестовая секция
if __name__ == "__main__":
    sorted_array = [1, 3, 5, 7, 9, 11, 13]
    search_target = 7
    result = fibonacci_search(sorted_array, search_target)
    
    if result is not None:
        print(f'Элемент {search_target} найден на позиции {result}')
    else:
        print('Элемент не найден')
