# Задание 5. Имитация отжига: оптимизация функции 


Условие. Минимизировать f(x)=x 2 на [−10,10] методом имитации отжига. 
Алгоритм: имитация отжига (Simulated Annealing). 
Язык примера: Java 
public static double saSquare(double temp, double cooling) { 
double x = Math.random() * 20 - 10; 
double energy = x * x; 
while (temp > 1e-6) { 
double xNew = x + (Math.random() * 2 - 1) * temp; 
double energyNew = xNew * xNew; 
// ДОПИСАТЬ: принять/отклонить xNew по критерию Метрополиса 
temp *= cooling; 
} 
return x; 
} 
Что дописать: условие принятия нового решения.

### Имитация отжига (Simulated Annealing, SA) — это вероятностный метаэвристический алгоритм оптимизации, вдохновлённый физическим процессом отжига в металлургии.
# Анализ алгоритма:


Алгоритм имитации отжига для оптимизации функции начинается с инициализации, где генерируется случайная начальная точка в диапазоне [-10, 10]. Строка double x = random.nextDouble() * 20 - 10 обеспечивает равномерное распределение начальных решений. Вычисление энергии через double energy = x * x задает целевую функцию для минимизации.
На каждой итерации генерируется соседнее решение в окрестности текущей точки. Строка double xNew = x + (random.nextDouble() * 2 - 1) * temp создает новое решение, где размер шага зависит от текущей температуры - при высоких температурах探索 более агрессивное, с охлаждением - более локальное.
Ключевой особенностью является вероятностный критерий в строках if (energyNew < energy || Math.random() < Math.exp(-(energyNew - energy) / temp)). Этот механизм позволяет принимать ухудшающие решения с вероятностью, определяемой разностью энергий и текущей температурой. При высоких температурах доминирует исследование пространства, с охлаждением - эксплуатация найденных решений.


Ограничение области поиска обеспечивается условиями if (xNew < -10) xNew = -10 и if (xNew > 10) xNew = 10, которые гарантируют, что решение остается в допустимом диапазоне.
Температурный режим управляется строкой temp *= cooling, реализующей геометрическое охлаждение. Экспоненциальное снижение температуры обеспечивает плавный переход между фазами поиска. Сохранение улучшающих решений через присваивание x = xNew и energy = energyNew гарантирует прогресс в оптимизации.
Алгоритм завершается при достижении минимальной температуры temp > 1e-6. Финальное решение представляет найденный минимум функции, достигаемый за счет комбинирования случайного поиска, температурного управления и вероятностного принятия решений.


# Временная сложность алгоритма: O(k), где:
k - количество итераций до достижения минимальной температуры.


### Почему: сложность определяется количеством итераций цикла while, которое зависит от начальной температуры и коэффициента охлаждения. На каждой итерации выполняются операции с постоянным временем O(1), поэтому общая сложность линейно зависит от числа итераций. Фактически, вы сами определяете сложность алгоритма, выбирая параметры температуры и охлаждения - чем медленнее охлаждение, тем лучше результат, но дольше выполнение.


# Ответ на контрольный вопрос:
Жадный алгоритм для 0-1 рюкзака: Почему жадный алгоритм для 0-1 рюкзака не гарантирует оптимальное решение? Приведите контрпример.
Жадный алгоритм для 0-1 рюкзака, основанный на выборке предметов с максимальным соотношением ценности к весу, не гарантирует оптимальное решение потому, что он не учитывает возможность комбинации менее "плотных" по ценности предметов, которые в сумме могут дать большую общую ценность.
Контрпример:
Вместимость рюкзака: 10
Предметы:
Предмет A: вес=6, ценность=60 (плотность=10)
Предмет B: вес=5, ценность=50 (плотность=10)
Предмет C: вес=5, ценность=50 (плотность=10)


Жадный алгоритм возьмет предмет A (ценность=60), но оптимальное решение - предметы B и C (общая ценность=100). Алгоритм не может разбить предмет A, поэтому принимает неоптимальное решение.
