#сортировка вставками

def insertion_sort(arr):
    # Проходим по массиву начиная со второго элемента (i=1)
    for i in range(1, len(arr)):
        key = arr[i]           # Сохраняем значение текущего элемента
        
        j = i - 1              # Перемещаемся назад от текущего индекса
        
        # Если предыдущий элемент больше текущего,
        # сдвигаем элементы вправо, освобождая место для вставки нового значения
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1             # Продолжаем двигаться назад
            
        # Когда находим правильное место для вставки ключа, помещаем его туда
        arr[j + 1] = key

# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(arr)
print("Отсортированный массив:", arr)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#быстрая сортировка
def quick_sort(arr):
    # Базовый случай: если длина массива равна нулю или единице,
    # то массив уже отсортирован и мы возвращаем его обратно
    if len(arr) <= 1:
        return arr
    
    # Выбираем первый элемент массива в качестве опорного ("pivot")
    pivot = arr[len(arr) // 2]
    
    # Разделяем массив на три списка:
    # left - элементы, меньшие опорного
    # middle - элементы равные опорному
    # right - элементы большие опорного
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    # Рекурсивно применяем быструю сортировку к левым и правым частям
    # и объединяем результаты вместе с элементами, равными опорному
    return quick_sort(left) + middle + quick_sort(right)

# Пример использования:
if __name__ == "__main__":
    unsorted_array = [3, 6, 8, 10, 1, 2, 1]
    sorted_array = quick_sort(unsorted_array)
    print(f'Отсортированный массив: {sorted_array}')
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#последовательный поиск
def sequential_search(arr, target):
    """
    Реализация последовательного поиска в массиве.
    :param arr: Список элементов, в котором осуществляется поиск.
    :param target: Элемент, который нужно найти.
    :return: Индекса элемента, если найден; иначе None.
    """
    # Пробегаемся по каждому элементу массива
    for index, element in enumerate(arr):
        # Если текущий элемент совпадает с искомым, возвращаем его индекс
        if element == target:
            return index
    # Если элемент не найден, возвращаем None
    return None

# Пример использования
if __name__ == "__main__":
    # Исходный массив
    my_list = [10, 20, 30, 40, 50]
    
    # Искомое значение
    search_value = 30
    
    # Производим поиск
    result = sequential_search(my_list, search_value)
    
    # Проверяем результат
    if result is not None:
        print(f"Значение найдено на позиции {result}.")
    else:
        print("Значение не найдено.")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#фибоначчи поиск
# Функция возвращает k-е число Фибоначчи рекурсивно
def fibonacci(k):
    if k <= 1:
        return k
    else:
        # вычисляем следующее число Фибоначчи путём суммирования двух предыдущих чисел
        return fibonacci(k-1) + fibonacci(k-2)

# Основная функция поиска методом Фибоначчи
def fibonacci_search(arr, target):
    n = len(arr)          # длина массива
    
    # находим наименьший индекс k, для которого fibonacci(k) >= n
    k = 0                 # начинаем с индекса 0 в ряду Фибоначчи
    while fibonacci(k) < n:
        k += 1            # увеличиваем k пока не найдем подходящее значение

    offset = -1           # начальное смещение
    
    # проверяем элементы массива начиная с индексов полученных из ряда Фибоначчи
    while (fibonacci(k) > 1):
        i = min(offset+fibonacci(k-2), n-1)   # определяем новый индекс для проверки
        
        # если элемент меньше искомого значения, смещаемся вправо
        if arr[i] < target:
            offset = i     # запоминаем последнее известное местоположение элемента меньшего целевого
            k -= 1         # уменьшаем k на единицу
            
        # если элемент больше искомого значения, смещаемся влево
        elif arr[i] > target:
            k -= 2         # уменьшаем k на две единицы
            
        # нашли нужный элемент
        else:
            return i       # возвращаем индекс найденного элемента
            
    # если мы вышли из цикла и ещё не нашли целевой элемент,
    # проверяем последний возможный вариант
    if(fibonacci(k-1) and arr[offset+1]==target):
        return offset+1
        
    # цель не была найдена
    return None

# Тестируем алгоритм
arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
target = 85
result = fibonacci_search(arr, target)
if result is not None:
    print("Элемент {} найден по индексу {}".format(target, result))
else:
    print("Элемент {} не найден".format(target))
