Павлова Мария 15.27Д-ПИ01/25б

Лабораторная работа №1

Сравнительный анализ реализации списков в Python, C++ и Java.

В Python процесс создания списка не вызывает сложностей — достаточно объявить структуру в квадратных скобках. Синтаксис отличается минимализмом и интуитивной понятностью («включил и работай»). В Java, напротив, требуется явно указывать тип переменной, а сама структура кода кажется менее привычной по сравнению с Python. Написание кода на Java сопряжено с дополнительными сложностями: например, ошибки компиляции могут возникать уже на этапе объявления строк. C++ по своему синтаксису отчасти напоминает Python, и тем, кто уже знаком с последним, будет проще адаптироваться к C++. Кроме того, этот язык обеспечивает высокую производительность. Однако в C++, в отличие от Python, обязательно ставить точку с запятой в конце инструкций, что поначалу может вызывать затруднения. Если расположить языки по возрастанию сложности освоения, общепринятая последовательность такова: Python, Java, C++. Хотя лично мне видится иной порядок: Python, C++, Java.

Исследование структуры STACK в Python, C++ и Java.

STACK — это способ организации данных, при котором новые элементы размещаются поверх предыдущих, подобно стопке. В Python для имитации стека создаётся пустой список, куда элементы добавляются с помощью append(i), а удаляются посредством pop([i]), который не только удаляет элемент на указанной позиции, но и возвращает его значение, что упрощает понимание логики работы. В Java подход во многом схож с Python. Добавление элементов выполняется с применением add(int index, element), а очистка стека — с помощью clear(). Таким образом, между реализациями в Python и Java наблюдается определённое сходство. C++ предлагает аналогичные методы, как в Java и Python, однако общая структура кода имеет свои особенности. Несмотря на это, прослеживается явная общность в используемых подходах. Важно отметить, что и в Java, и в C++ можно создать классический стек, тогда как в Python такая возможность отсутствует — здесь стек лишь имитируется средствами списка.

Лабораторная работа №2

Мультисписок — это структура данных, в которой каждый элемент одновременно принадлежит нескольким односвязным спискам. В Python для его представления используется внешний цикл для перебора строк и внутренний — для элементов строки, а также метод join для вывода строки списка. В C++ можно применять класс multiset из STL или структуру двусвязного списка с указателями prev и next, по умолчанию инициализируемыми как NULL. В JAVA мультисписок реализуется с помощью коллекций ArrayList, LinkedList, CopyOnWriteArrayList или Stream API.

Очередь — это линейная структура данных, состоящая из последовательности элементов, организованных по принципу «первый вошёл — первый вышел». В Python для работы с очередью используется класс PriorityQueue (для учёта приоритетов) и библиотека deque, поддерживающая добавление и удаление элементов с обоих концов. В C++ применяется std::queue (FIFO) и priority_queue (для извлечения по приоритету). В JAVA используются классы LinkedList, ArrayDeque и PriorityQueue.

Дек (двусторонняя очередь) — это структура, позволяющая добавлять и удалять элементы как в начале, так и в конце последовательности. В Python для его реализации используется двусторонняя очередь из модуля collections. В C++ применяется контейнер deque, обеспечивающий эффективное добавление и удаление с обоих концов. В JAVA дек можно представить с помощью классов ArrayDeque и LinkedList.

Приоритетная очередь — это абстрактный тип данных, в котором элементы обрабатываются в соответствии с их приоритетом, а не порядком добавления. В Python она реализуется через класс PriorityQueue или модуль heapq (на основе бинарной кучи), поддерживающие операции push() (добавление), pop() (удаление элемента с наивысшим приоритетом), top() (получение элемента без удаления), empty() (проверка на пустоту) и size() (количество элементов). В C++ используется контейнер priority_queue из STL. В JAVA приоритетная очередь поддерживает как естественный порядок (Comparable), так и пользовательский компаратор (Comparator).

Лабораторная 3

Бинарная,биноминальная куча, куча Фибоначчи, хеш-таблицы, как структуры данных в программировании

Бинарная куча — это полное бинарное дерево, которое может быть двух типов в зависимости от порядка элементов: минимальная (каждый узел содержит минимальное значение в своём поддереве) и максимальная (каждый узел содержит максимальное значение в своём поддереве). В Python её можно реализовать с помощью модуля heapq или создать собственный класс. В C++ для этого используются встроенные средства (например, priority_queue с соответствующим компаратором). В JAVA применяется класс BinaryHeap.

Биномиальная куча — это абстрактный тип данных «очередь с приоритетом», который также поддерживает операцию слияния двух куч (является сливаемой кучей). В Python для работы с ней можно использовать модуль heapq. В C++ реализация включает методы: Union() (объединяет две биномиальные кучи), Insert(h, key) (вставляет ключ в кучу), GetMin(h) (возвращает наименьший ключ), ExtractMin(h) (удаляет минимальный узел и объединяет его поддеревья), DecreaseKey(h) (уменьшает ключ узла) и Delete(h) (удаляет узел через уменьшение ключа и извлечение минимума). В JAVA используется класс BinomialHeap.

Куча Фибоначчи — это набор деревьев, упорядоченных в соответствии со свойством неубывающей пирамиды: ключ каждого узла не меньше ключа его родительского узла. В Python её можно представить с помощью класса FibonacciHeap, который включает инициализацию (создание узлов, переменных min_node, num_nodes), метод create_node(int value) для создания узла, вставку узлов (insert(ключ)), а также функцию fibonacci_iterative(n) для вычисления чисел последовательности. В C++ реализация содержит функции: insert(key) (вставка элемента), getMin() (возврат минимального элемента), extractMin() (извлечение и удаление минимума), decreaseKey(element, new_key) (уменьшение ключа), deleteElement(element) (удаление элемента) и isEmpty() (проверка на пустоту). В JAVA применяется рекурсивный алгоритм для последовательности Фибоначчи (класс Fibonacci).

Хеш-таблица — это структура данных, реализующая интерфейс ассоциативного массива и позволяющая хранить пары «ключ-значение» с операциями добавления, поиска и удаления. В Python используются методы: insert() (добавление пары), search() (быстрый поиск значения по ключу), delete() (удаление пары); также применяются стандартный тип dict, метод цепочек (отдельное хеширование) и двойное хеширование. В C++ хеш-таблица реализуется с помощью класса std::unordered_map, использующего методы insert(), emplace() (вставка пар), find() (поиск, возвращает итератор на пару), end() (сигнализирует об отсутствии ключа) и erase() (удаление элемента). Пример: unordered_map<string, int> umap — создание, umap["ключ"] = значение — вставка. В JAVA для этого используются классы Hashtable и HashMap.



Лабораторная 4

Деревья и графы, как структуры данных в программировании
Дерево — это иерархическая структура данных, состоящая из узлов. В Python для работы с деревьями используются различные реализации, включая бинарное дерево поиска (BST) и префиксное дерево (Trie). Бинарное дерево реализуется через класс TreeNode для создания узлов и класс BinarySearchTree с основными операциями: insert (вставка), search (поиск), delete (удаление) и inorder_traversal (симметричный обход). Для более специализированных задач применяются библиотеки anytree (создание и визуализация), treelib (простая работа с деревьями) и scikit-learn (деревья для машинного обучения). Префиксное дерево реализуется через класс TrieNode со словарём children и методами insert, search, startsWith (поиск по префиксу) и delete.

В C++ деревья часто представляются в виде сбалансированных структур, таких как красно-чёрное дерево. Оно поддерживает основные методы: insert (добавление узла), search (поиск с возвратом указателя или nullptr), size (количество элементов), height (высота дерева), empty (проверка на пустоту) и erase (удаление узла по ключу). Для поддержания баланса используются вспомогательные функции: update (обновление атрибутов узла), leftRotate и rightRotate (левое и правое вращения для балансировки структуры).

Таким образом, деревья как структуры данных обеспечивают эффективное хранение и обработку иерархической информации, а их реализация в разных языках программирования предлагает как базовые операции работы с узлами, так и специализированные методы для балансировки и обхода структуры, что делает их универсальным инструментом для решения различных computational tasks.
